ch01-static-proxy:静态代理，代理类是自己创建的，代理目标类是固定的

实现步骤：
1，创建一个接口，定义买u盘的方法，表示你的厂家和商家做的事情
2，创建厂家类，实现步骤1
3，创建商家类，就是代理，也需要实现步骤1中的接口
4，创建客户端类，调用商家方法买一个U盘。
功能完成
1.目标类调用
2.功能增强

静态代理特点，实现简单，容易理解
当目标类和代理类增加的时候：缺点当目标类增加的时候代理类也需要成倍的增加，代理数量过多  当你的接口中功能增加了，或者修改了，会影响很多的实现类，厂家类
，代理商都需要修改，影响比较多，不易维护
动态代理
在静态代理中目标类很多的时候，可以使用动态代理，避免静态代理的缺点
动态代理中即使目标类有很多  1代理类可以很少 ，当你修改了接口方法时不会影响代理类
动态代理：在程序执行过程中，使用jdk的反射机制，创建代理对象，并且动态的指定要代理的目标类
换句话说动态代理是一种创建java对象的能力，让你不用创建Taobao类就能创建代理目标类对象


动态代理的实现
1.jdk动态代理（理解）：使用java反射包中的类和接口实现动态代理对象
反射包 java.lang.reflect , 里面有3个类 :InvocationHandler,method.proxy
 2cglib动态代理（了解）cglib是第3方工具类库，创建代理对象
 从管理部的原理是继承，cglib通过继承目标类，创建他的子类在子类中
 重写父类中同名的方法，实现功能的修改
 因为cglib是继承重写方法 使用要求目标类不能是funal的 ，方法也不能是final、的从管理部的要求
 目标类比较宽松，只要能继承就可以了，cglib在很多框架中使用，比如mybatis  spring都有